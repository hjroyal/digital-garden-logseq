- **快速制作旅游攻略**
	- tags:: 游山玩水
	- [五一出游懒人必备！一键生成旅行攻略！ - 小红书 (xiaohongshu.com)](https://www.xiaohongshu.com/explore/6629faab00000000040189b7?app_platform=ios&app_version=8.33&share_from_user_hidden=true&type=video&author_share=1&xhsshare=WeixinSession&shareRedId=ODo6Rkg5OU42NzUyOTgwNjczOThKR0o7&apptime=1714187210)
-
- **qpc移植**
	- tags:: qpc, qm, UML
	- [Blinky实例分析来认识一下QP状态机 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI5NzM5MjMxNw==&mid=2247495440&idx=1&sn=2f38b7a1bc16fbbc5900ba6b37afc1cb&chksm=ecb76ec2dbc0e7d4b7cf11d65a662585846eeed2e8e0ff6e9c43c78b3fe17e90ce3dcadef60b&mpshare=1&scene=1&srcid=0426t8NHzaghSgkNGIdFrMpN&sharer_shareinfo=5f24019d40722acfdc6c704fdbeea45c&sharer_shareinfo_first=5f24019d40722acfdc6c704fdbeea45c#rd)
		- 不知道大家看到上面解释中的代码有没有疑惑，BSP_ledOn()函数啥都没有啊，难道不应该控制某个gpio口来控制led灯的状态吗？
		- 这里是**专门被设计成了不需要直接访问目标资源，不写入特定的嵌入式主板的GPIO，而是访问调用封装好的BSP，这样就不需要改变它的状态机代码了。**
		- 对于不同的硬件平台，状态机实现代码（blinky.c）是一样的，只需要更改bsp包就行
	- 官网参考手册
		- [QP/C: Overview (state-machine.com)](https://www.state-machine.com/qpc/)
		- [QP/C++: Overview (state-machine.com)](https://www.state-machine.com/qpcpp/)
		- [QM: About QM™ (state-machine.com)](https://www.state-machine.com/qm/)
		- [QTools: Overview (state-machine.com)](https://www.state-machine.com/qtools/)
			- [QTools: QP/Spy™ Software Tracing (state-machine.com)](https://www.state-machine.com/qtools/qpspy.html)
			- [QTools: QUTest™ Unit Testing Harness (state-machine.com)](https://www.state-machine.com/qtools/qutest.html)
			- [QTools: QView™ Visualization & Monitoring (state-machine.com)](https://www.state-machine.com/qtools/qview.html)
			- [QTools: QWin™ GUI Prototyping Toolkit (state-machine.com)](https://www.state-machine.com/qtools/qwin.html)
	- **Application Notes & Articles**
		- [QP/C: ARM Cortex-M (state-machine.com)](https://www.state-machine.com/qpc/arm-cm.html)
		- ==ARM Cortex-M== ports
			- 路径位置
			  collapsed:: true
				- ```
				  qp/ports/arm-cm     // QP ports to ARM Cortex-M
				  +---qk              // ports to QK preemptive kernel
				  |   +---armclang    // ports for ARM-CLANG (LLVM)
				  |   |       qp_port.h   // QP port
				  |   |       qs_port.h   // QS port
				  |   |       qk_port.c   // QK port implementation
				  |   +---gnu         // ports for GNU-ARM
				  |   |       ~ ~ ~
				  |   +---iar         // ports for IAR EWARM
				  |   |       ~ ~ ~
				  +---qv              // ports to QV non-preemptive kernel
				  |   +---armclang    // ports for ARM-CLANG (LLVM)
				  |   |       qp_port.h   // QP port
				  |   |       qs_port.h   // QS port
				  |   |       qv_port.c   // QV port implementation
				  |   +---gnu         // ports for GNU-ARM
				  |   |       ~ ~ ~
				  |   +---iar         // ports for IAR EWARM
				  |   |       ~ ~ ~
				  +---qxk             // ports to QXK dual-mode kernel
				  |   +---armclang    // ports for ARM-CLANG (LLVM)
				  |   |       qp_port.h   // QP port
				  |   |       qs_port.h   // QS port
				  |   |       qxk_port.c  // QXK port implementation
				  |   +---gnu         // ports for GNU-ARM
				  |   |       ~ ~ ~
				  |   +---iar         // ports for IAR EWARM
				  |   |       ~ ~ ~
				  ```
			- 与任何实时内核一样，QP/C 实时框架需要禁用中断才能访问代码的关键部分，并在完成后重新启用中断。
			- 只有“内核感知”中断才能调用 QP/C 服务。“内核无感知”中断**不允许**调用任何 QP/C 服务，它们只能通过触发“内核感知”中断（可以发布或发布事件）来与 QP/C 通信。
				- STM32 MCU实现4个优先级位（见下图）。CMSIS标准提供宏NVIC_PRIO_BITS，该**宏**指定在给定ARM Cortex-M实现中定义的NVIC优先级位数。
				- ![](https://www.state-machine.com/qpc/arm-cm_int4bit.png)
		- 在嵌入式系统中，除非一切正常，否则什么都不起作用。这意味着您应该始终从一个**工作系统**开始并逐渐发展它，一次更改一件事，并确保它在每一步都保持工作状态。
- **C语言实现面向对象思想**
	- tags::   c，OOP, qpc
	- [qpstudy: QP学习例程，包含博客与例程代码，旨在将众多的QP初学者认识到QP的价值。 (gitee.com)](https://gitee.com/woodman_112/qpstudy)
	- QP颠覆了之前的**前后台**和**RTOS**的思维逻辑。
	- **嵌入式软件不仅是软件工程，更是系统工程**
		- 嵌入式软件，从来都不是纯粹的软件，而是与硬件（PCB、器件、执行机构、传感器、显示部件）等紧密相关。
	- [blog/当单片机遇上状态机 入门QP.md · woodman/qpstudy - 码云 - 开源中国 (gitee.com)](https://gitee.com/woodman_112/qpstudy/blob/master/blog/%E5%BD%93%E5%8D%95%E7%89%87%E6%9C%BA%E9%81%87%E4%B8%8A%E7%8A%B6%E6%80%81%E6%9C%BA%20%E5%85%A5%E9%97%A8QP.md)
	- 在QP中，AO（Active Object）是核心，QP的所有功能都是围绕AO展开的，就好比在RTOS中任务是核心一样。AO之间，纯粹靠事件进行通信，原则上是不允许AO间共享全局变量的。
	- ==发布-订阅模式==的最大好处，就是模块间的彻底解耦。这里插入一个程序设计原则，好的程序，一定是解耦良好的程序。所谓耦合，就是模块A变了，模块B也得跟着变，否则，B模块会运行不正常，模块之间有依赖；所谓解耦，就是去除模块之间的依赖，模块A变了，模块B无须改变。
-